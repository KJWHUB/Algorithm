<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

  <h1>소수 찾기</h1>

  <h3>문제 설명</h3>
  <p>
    한자리 숫자가 적힌 종이 조각이 흩어져있습니다.
    흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.
    각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.
  </p>

  <h3>제한사항</h3>
  <p>
    numbers는 길이 1 이상 7 이하인 문자열입니다.
    numbers는 0~9까지 숫자만으로 이루어져 있습니다.
    "013"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다. 
  </p>

  <h3>입출력 예</h3>
  <div>
    numbers	return
    "17"	3
    "011"	2
  </div>

</body>
</html>

<script>
// 내가 짠 코드
// function solution(numbers) {
//   const arr = [...numbers]
//   const list = []

//   // 소수판별
//   const integer2 = (n) => Number.isInteger(n/2)

//   console.log(arr)

//   const map = arr.map((el, index) => {
//     const copy = [...arr]
//     let reArr = []
//     copy.splice(index, 1)
//     copy.forEach((el1) => {
//       const temp1 = el + el1
//       const temp2 = el1 + el
//       reArr.push(temp1, temp2)
//     })
//     return reArr
//   })

//   const flat = map.flat()

//   const set1 = new Set(flat)
//   const set1Arr = [...set1].map((el) => Number(el))

//   let cnt = 0

//   set1Arr.forEach((el) => {
//     if (!integer2(el)) {
//       cnt++
//     }
//   })

//   console.log(map)
//   console.log(flat)
//   console.log(set1Arr)
//   console.log(cnt)



//   return 1;
// }

function solution(numbers) {
  const arr = [...numbers]
  let cnt = 0
  // 소수판별 소수라면(ture)
  const integer2 = (n) => {
    if (n === 1) {
      return false
    } else if (n === 2) {
      return true
    } else if (Number.isInteger(n/2)) {
      return false
    } else {
      return true
    }
  }
  // 배열의 합
  const arrPlus = (arr) => Number(arr.reduce((acc, curr) => acc + curr))
  
  // 재귀함수
  const zgfn = (n, arr) => {
    const copy = [...arr]
    copy.push(n)
  }
  arr.forEach((el, i) => {
    const list = []
    list.length = arr.length
    zgfn(el, list)
  })

  
  return 1;
}

// 7
// 17
// 71

// '0'
// '0123456'

const numbers = '011'

console.log(solution(numbers))














function dfs(graph, startNode) {
  let visited = {};
  let dfsResult = [];

  function dfsRecursion(node) {
    if (!node) {
      return null;
    }
    visited[node] = true;
    dfsResult.push(node);
    graph[node].forEach((adjacentNode) => {
      if (!visited[adjacentNode]) {
        dfsRecursion(adjacentNode);
      }
    });
  }
  dfsRecursion(startNode);
  return dfsResult;
}

// 예시 그래프
let graph = {
  A: ['B', 'C'],
  B: ['A', 'D', 'E'],
  C: ['A', 'F'],
  D: ['B'],
  E: ['B', 'F'],
  F: ['C', 'E']
};

console.log(dfs(graph, 'A')); // [ 'A', 'B', 'D', 'E', 'F', 'C' ]



</script>